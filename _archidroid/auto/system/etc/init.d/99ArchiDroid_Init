#!/system/bin/sh

# ArchiDroid Init Script
# JustArchi@JustArchi.net
# Don't remove this file

# Not Disabled
#exit 0

ADALIAS() {
	# Because fuck you kernel, that's why
	local CMD="$1"
	shift 1
	if [ -e /system/xbin/$CMD ]; then
		/system/xbin/$CMD "$@"
	elif [ -e /system/bin/$CMD ]; then
		/system/bin/$CMD "$@"
	else
		$CMD "$@"
	fi
}

ADARGS() {
	# $1 - what we're looking for
	# $2 - where we're looking for
	if [ ! -z `echo "$2" | grep -i "$1"` ]; then
		return 0
	else
		return 1
	fi
}

ADTWEAK() {
	# $1 - what we're changing
	# $2 - to what we're changing
	local CURRENT=`cat "$1"`
	echo "$2" > "$1"
	echo "INFO: Tweaked $1 value from $CURRENT to $2" >> $LOG
}

# Define all unreliable commands, which kernel could override
# It's really sad that we're doing this
alias busybox='ADALIAS busybox'
alias sh='ADALIAS sh'
alias exec='ADALIAS exec'
alias kill='ADALIAS kill'
alias echo='ADALIAS echo'
alias reboot='ADALIAS reboot'
alias sqlite3='ADALIAS sqlite3'
alias tinyplay='ADALIAS tinyplay'
alias mount='ADALIAS mount'

# Initial variables, you should NOT change them unless you know what you're doing
AD="/data/media/0/ArchiDroid"
LOG="$AD/Init.log" # "/dev/null" is no verbose
RUNONCELOG="$AD/RunOnce.log"
ADSTATUS="/dev/ARCHIDROID_INIT_STATUS"

if [ ! -e $ADSTATUS ]; then
	# First boot, good
	echo $$ > $ADSTATUS
else
	ADSIGNAL=`cat $ADSTATUS`
	if [ $ADSIGNAL == "FINISHED" ]; then
		# Something tried to execute already finished init, halt
		echo "This script has been executed already"
		exit 0
	elif [ $ADSIGNAL == "RESTART" ]; then
		# Backend restarts itself, good to know, allow that
		echo $$ > $ADSTATUS
	else
		kill -s 0 $ADSIGNAL >/dev/null 2>&1
		ADSIGNAL=$?
		if [ $ADSIGNAL -eq 0 ]; then
			# Something tried to execute already running init, double-execution?
			exit 3
		else
			# Old PID is dead and didn't exit properly, allow that for now
			echo $$ > $ADSTATUS
		fi
	fi
fi

# Redirect stderr to our log, just in case something bad happen
#exec 1>$LOG # Use "exec 1>>$LOG" for append
echo -n "" > $LOG
exec 2>>$LOG

# Parse args to variables
if ADARGS "background" "$@" ; then
	BACKGROUND=1
else
	BACKGROUND=0
fi
if ADARGS "force" "$@" ; then
	FORCE=1
else
	FORCE=0
fi

echo "`date`" >> $LOG
echo "ArchiDroid `getprop ro.archidroid.version`" >> $LOG
echo "`uname -a`" >> $LOG
echo "INFO: ArchiDroid_Init executed!" >> $LOG

if [ -e /system/etc/init.d/98ArchiDroid_RunOnce ] && [ $FORCE -ne 1 ]; then
	# This is our first boot, don't call init yet
	echo "INFO: This is our first boot, I'll let RunOnce finish his job, exiting..." >> $LOG
	echo "RESTART" > $ADSTATUS
	exit 2
fi

# Now we need to make sure that this is background process to prevent slowing down bootup
if [ $BACKGROUND -ne 1 ]; then
	# We're not running in background, let's start a child and tell him that he's running in background
	echo "INFO: Spawning child!" >> $LOG
	echo "RESTART" > $ADSTATUS
	sh $0 "background" &
	
	# Nothing to do here anymore, exit call
	exit 1
else
	# We're running in background so let's proceed
	echo "INFO: I'm a child!" >> $LOG
fi


#   ____
#  / ___| ___   _ __  ___
# | |    / _ \ | '__|/ _ \
# | |___| (_) || |  |  __/
#  \____|\___/ |_|   \___|
#

# Which mode are we using?
# 0 - CyanogenMod
# 1 - Sammy
# 2 - Omni
ROM=1 # Default to sammy
if [ `cat /system/build.prop | grep "ro.omni.version" | wc -l` -gt 0 ]; then
	ROM=2 # OK, definitely Omni
elif [ `cat /system/build.prop | grep "ro.cm.version" | wc -l` -gt 0 ]; then
	ROM=0 # OK, definitely CM
fi

# Bring su daemon if available
if [ -e /system/xbin/daemonsu ]; then
	echo "INFO: SuperSU daemon found, calling daemonsu!" >> $LOG
	/system/xbin/daemonsu --auto-daemon &
fi

# Custom boot sound support
if [ -e $AD/PowerOn.wav ]; then
	tinyplay $AD/PowerOn.wav > /dev/null 2>&1 &
fi

# Cool ArchiDroid Banner
if [ -e /system/bin/boot-dmesg ]; then
	echo "INFO: boot-dmesg detected, turning on logcat banner" >> $LOG
	ADBANNER=1
else
	echo "INFO: boot-dmesg NOT detected, turning off logcat banner" >> $LOG
	ADBANNER=0
fi

# Haveged support
echo "INFO: Activating haveged!" >> $LOG
ENTROPY=3072 # Default: 128, Linux: 896, Max: 4096 - We want to make it high enough, but with considering battery life as well
ADTWEAK "/proc/sys/kernel/random/write_wakeup_threshold" "$ENTROPY"
ADTWEAK "/proc/sys/vm/dirty_expire_centisecs" "1000"
ADTWEAK "/proc/sys/vm/dirty_writeback_centisecs" "500"
haveged -p /dev/ARCHIDROID_HAVEGED.PID
sleep 5 # Let's give haveged some time to initialize
echo "INFO: HArdware Volatile Entropy Gathering and Expansion Daemon activated!" >> $LOG
echo "HAVEGED: Available entropy won't get below $ENTROPY" >> $LOG

# Frandom support
if [ ! -c /dev/frandom ]; then
	echo "INFO: frandom device not found, searching for frandom.ko kernel module..." >> $LOG
	for FRANDOMPATH in "/system/lib/modules" "/system/modules" "/lib/modules" "/modules"; do
		if [ -f $FRANDOMPATH/frandom.ko ]; then
			echo "INFO: Loading frandom using $FRANDOMPATH/frandom.ko!" >> $LOG
			insmod $FRANDOMPATH/frandom.ko
			sleep 1
			break
		fi
	done
fi
if [ -c /dev/frandom ]; then
	echo "INFO: frandom device found, activating erandom!" >> $LOG
	if [ ! -e /dev/urandom.ORIG ] && [ ! -e /dev/urandom.orig ] && [ ! -e /dev/urandom.ori ]; then
		# For compatibility with various CrossBreeder checks
		touch /dev/urandom.MOD
		touch /dev/random.MOD 

		mv /dev/urandom /dev/urandom.ORIG
		ln /dev/erandom /dev/urandom
		busybox chmod 644 /dev/urandom
		mv /dev/random /dev/random.ORIG
		ln /dev/erandom /dev/random
		busybox chmod 644 /dev/random
		echo "INFO: Activated!" >> $LOG
	else
		echo "INFO: It looks like frandom has been already loaded" >> $LOG
	fi
else
	echo "INFO: frandom device not found after loading, it looks like it's not provided by your kernel or failed to load!" >> $LOG
fi

# Adblock support
echo "INFO: Activating ArchiDroid's AdBlock!" >> $LOG
dnsproxy2 -w 127.0.0.1 &
echo "ADBLOCK: Activated forwarding of all DNS requests (dnsproxy2) to 127.0.0.1:53 (dnrd)" >> $LOG
dnrd -u 0 -r 0 -M 65535 -m hosts -s 127.0.0.1 -R /system/archidroid/dnrd
echo "ADBLOCK: Activated local DNS-firewall server (dnrd) on 127.0.0.1:53, forwarding clean traffic to 127.0.0.1:10053 (dnsmasq)" >> $LOG
dnsmasq_dhcp --all-servers -C /system/archidroid/etc/dnsmasq.conf -n --user=root -x /dev/ARCHIDROID_DNSMASQ.PID -a 127.0.0.1 -z -p 10053 -h -S 8.8.8.8 -S 8.8.4.4
echo "ADBLOCK: Activated local DHCP/DNS server (dnsmasq) on 127.0.0.3:10053, forwarding traffic to 8.8.[8.8/4.4]" >> $LOG 
pixelserv 127.0.0.1 >/dev/null 2>&1
echo "ADBLOCK: Activated NULLGIF response (pixelserv) on 127.0.0.1:80" >> $LOG
echo "INFO: ArchiDroid's AdBlock activated!" >> $LOG

# Sqlite VACUUM & REINDEX, disabled for a while
if [ $ROM -eq 9 ]; then #Always false
	echo "INFO: Performing VACUUM & REINDEX of databases" >> $LOG
	mount -o remount,rw /
	for i in `busybox find /data/data -iname "*.db"`; do
		sqlite3 $i 'VACUUM;'
		sqlite3 $i 'REINDEX;'
	done
	for i in `busybox find /data/system -iname "*.db"`; do
		sqlite3 $i 'VACUUM;'
		sqlite3 $i 'REINDEX;'
	done
	mount -o remount,ro /
fi

# Zipalign, disabled for a while
if [ $ROM -eq 9 ]; then #Always false
	echo "INFO: Performing ZIPALIGN of apks" >> $LOG
	for apk in /data/app/*.apk ; do
		zipalign -c 4 $apk;
		ZIPCHECK=$?;
		if [ $ZIPCHECK -eq 1 ]; then
			zipalign -f 4 $apk /cache/$(basename $apk)
			if [ -e /cache/$(basename $apk) ]; then
				cp -f /cache/$(basename $apk) $apk
				rm -f /cache/$(basename $apk)
				busybox chmod 644 $apk
			fi
		fi
	done
fi

# ArchiDroid Semaphore
# Wait until we see some android processes to consider boot is more or less complete (credits to AndiP71)
# Also respect number of loops, maybe something went wrong
echo "INFO: Init Semaphore started" >> $LOG
LOOP=0
while ! pgrep com.android && [ $LOOP -lt 300 ] ; do
	if [ $ADBANNER -eq 1 ]; then
		echo "
*******************************************************************************
*             _                _      _  ____               _      _          *
*            / \    _ __  ___ | |__  (_)|  _ \  _ __  ___  (_)  __| |         *
*           / _ \  | '__|/ __|| '_ \ | || | | || '__|/ _ \ | | / _\` |         *
*          / ___ \ | |  | (__ | | | || || |_| || |  | (_) || || (_| |         *
*         /_/   \_\|_|   \___||_| |_||_||____/ |_|   \___/ |_| \__,_|         *
*                                                                             *
*******************************************************************************
*                  _                       _  _                               *
*                 | |     ___    __ _   __| |(_) _ __    __ _                 *
*                 | |    / _ \  / _\` | / _\` || || '_ \  / _\` |                *
*                 | |___| (_) || (_| || (_| || || | | || (_| |                *
*                 |_____|\___/  \__,_| \__,_||_||_| |_| \__, |                *
*                                                       |___/                 *
*******************************************************************************
*            root@ArchiDroid:~# Waiting for ArchiDroid to load...             *
*******************************************************************************
"
	fi
	LOOP=`expr $LOOP + 1`
	sleep 2
done

if [ $LOOP -ge 300 ]; then
	echo "ERROR: I looped $LOOP times and needed to exit from infinite loop, not good (Init Semaphore)" >> $LOG
else
	echo "INFO: I looped $LOOP times and didn't have to exit from infinite loop, that's nice (Init Semaphore)" >> $LOG
fi

if [ -e /dev/block/mmcblk1p1 ] && [ `mount | grep -i "sdcard1" | wc -l` -eq 0 ] && [ `mount | grep -i "extSdCard" | wc -l` -eq 0 ]; then
	# Temporary workaround for mounting exFAT-formatted cards
	# Initial idea by AndiP71, aka Lord Boeffla
	# Further improvements by JustArchi

	echo "INFO: Detected sd card but it's not mounted yet" >> $LOG
	echo "INFO: Giving Android 30 more seconds to initialize external sd card..." >> $LOG
	sleep 30
	echo "INFO: Time passed!" >> $LOG
	if [ `mount | grep -i "sdcard1" | wc -l` -eq 0 ] && [ `mount | grep -i "extSdCard" | wc -l` -eq 0 ]; then
		echo "INFO: External sd card is still not mounted, mounting..." >> $LOG
		KEEPGOING=1
		if [ `lsmod | grep "exfat" | wc -l` -eq 0 ]; then
			echo "WARNING: No exfat module found, it's either compiled in kernel or not loaded. Blindly loading..." >> $LOG
			busybox insmod /system/lib/modules/exfat_core.ko >/dev/null 2>&1
			busybox insmod /system/lib/modules/exfat_fs.ko >/dev/null 2>&1
			echo "INFO: Blind load completed, proceeding with mounting now..."
		fi

		if [ -e /storage/sdcard1 ]; then
			EXTSDPATH="/storage/sdcard1"
		elif [ -e /storage/extSdCard ]; then
			EXTSDPATH="/storage/extSdCard"
		else
			EXTSDPATH="UNKNOWN"
		fi

		if [ -e /dev/block/vold/179:49 ]; then
			EXTSDMOUNT="/dev/block/vold/179:49"
			echo "INFO: Mounting through vold 179:49!" >> $LOG
			busybox mount -t auto -o rw,dirsync,nosuid,nodev,noexec,noatime,nodiratime,uid=1000,gid=1023,fmask=0002,dmask=0002,allow_utime=0020 $EXTSDMOUNT $EXTSDPATH >/dev/null 2>&1
			if [ `mount | grep -i "sdcard1" | wc -l` -eq 0 ] && [ `mount | grep -i "extSdCard" | wc -l` -eq 0 ]; then
				echo "WARNING: Failed!" >> $LOG
			else
				echo "INFO: Success!" >> $LOG
				KEEPGOING=0
			fi
		fi

		if [ $KEEPGOING -eq 1 ]; then
			EXTSDMOUNT="/dev/block/mmcblk1p1"
			echo "INFO: Mounting through mmcblk1p1!" >> $LOG
			busybox mount -t auto -o rw,dirsync,nosuid,nodev,noexec,noatime,nodiratime,uid=1000,gid=1023,fmask=0002,dmask=0002,allow_utime=0020 $EXTSDMOUNT $EXTSDPATH >/dev/null 2>&1
			if [ `mount | grep -i "sdcard1" | wc -l` -eq 0 ] && [ `mount | grep -i "extSdCard" | wc -l` -eq 0 ]; then
				echo "WARNING: Failed!" >> $LOG
			else
				echo "INFO: Success!" >> $LOG
				KEEPGOING=0
			fi
		fi

		if [ $KEEPGOING -eq 1 ]; then
			echo "INFO: Trying panic mode!" >> $LOG
			EXTSDMOUNT="/dev/block/vold/179:49"
			mount -t exfat -o rw,dirsync,nosuid,nodev,noexec,noatime,nodiratime,uid=1000,gid=1023,fmask=0002,dmask=0002,allow_utime=0020 $EXTSDMOUNT $EXTSDPATH >/dev/null 2>&1
			mount -t ext4 -o rw,dirsync,nosuid,nodev,noexec,noatime,nodiratime,uid=1000,gid=1023,fmask=0002,dmask=0002,allow_utime=0020 $EXTSDMOUNT $EXTSDPATH >/dev/null 2>&1
			mount -t vfat -o rw,dirsync,nosuid,nodev,noexec,noatime,nodiratime,uid=1000,gid=1023,fmask=0002,dmask=0002,allow_utime=0020 $EXTSDMOUNT $EXTSDPATH >/dev/null 2>&1
			EXTSDMOUNT="/dev/block/mmcblk1p1"
			mount -t exfat -o rw,dirsync,nosuid,nodev,noexec,noatime,nodiratime,uid=1000,gid=1023,fmask=0002,dmask=0002,allow_utime=0020 $EXTSDMOUNT $EXTSDPATH >/dev/null 2>&1
			mount -t ext4 -o rw,dirsync,nosuid,nodev,noexec,noatime,nodiratime,uid=1000,gid=1023,fmask=0002,dmask=0002,allow_utime=0020 $EXTSDMOUNT $EXTSDPATH >/dev/null 2>&1
			mount -t vfat -o rw,dirsync,nosuid,nodev,noexec,noatime,nodiratime,uid=1000,gid=1023,fmask=0002,dmask=0002,allow_utime=0020 $EXTSDMOUNT $EXTSDPATH >/dev/null 2>&1
			if [ `mount | grep -i "sdcard1" | wc -l` -eq 0 ] && [ `mount | grep -i "extSdCard" | wc -l` -eq 0 ]; then
				echo "WARNING: Failed!" >> $LOG
			else
				echo "INFO: Success!" >> $LOG
				KEEPGOING=0
			fi
		fi

		if [ `mount | grep -i "sdcard1" | wc -l` -eq 0 ] && [ `mount | grep -i "extSdCard" | wc -l` -eq 0 ]; then
				echo "ERROR: I failed to mount external sd card with automatic filesystem. Giving up here!" >> $LOG
		else
			echo "INFO: Successfully mounted external sd card!" >> $LOG
		fi
	else
		echo "INFO: OK, Android mounted our external sd card in given 30 seconds, aborting workaround" >> $LOG
	fi
else
	echo "INFO: OK, I don't need to mount external sd card" >> $LOG
fi

# Execute a reboot if we need it
if [ -e $AD/HARD_REBOOT_REQUIRED ]; then
	echo "INFO: HARD_REBOOT_REQUIRED found, I'm rebooting device now..." >> $LOG
	rm -f $AD/SOFT_REBOOT_REQUIRED
	rm -f $AD/HARD_REBOOT_REQUIRED
	tinyplay $AD/System/reboot.wav > /dev/null 2>&1
	reboot
elif [ -e $AD/SOFT_REBOOT_REQUIRED ]; then
	echo "INFO: SOFT_REBOOT_REQUIRED found, I'm rebooting android interface now..." >> $LOG
	rm -f $AD/SOFT_REBOOT_REQUIRED
	tinyplay $AD/System/reboot.wav > /dev/null 2>&1
	killall system_server
fi

sleep 10

if [ -e /system/etc/init.d/98ArchiDroid_RunOnce ]; then
	echo "WARNING: RunOnce found in init.d, trying to remove it!" >> $LOG
	echo "REMOTE: Hello, Init here. Don't worry about FATAL ERROR above, I'll try to fix it!" >> $RUNONCELOG
	echo "REMOTE: Dear user, you should look for RunOnce.log.0, it may contain more interesting RunOnce stuff!" >> $RUNONCELOG
	sysrw || mount -o remount,rw /system
	rm -f /system/etc/init.d/98ArchiDroid_RunOnce
	if [ ! -e /system/etc/init.d/98ArchiDroid_RunOnce ]; then
		echo "INFO: Success!" >> $LOG
		echo "REMOTE: Successfully fixed above FATAL ERROR!" >> $RUNONCELOG
		sysro || mount -o remount,ro /system
	else
		echo "ERROR: Failed!" >> $LOG
		echo "REMOTE: ERROR, could not fix above FATAL ERROR! Please investigate!" >> $RUNONCELOG
	fi
fi

# Init finished
echo "FINISHED" > $ADSTATUS
if [ ! -e /dev/ARCHIDROID_HAS_INIT ]; then
	echo "WARNING: It looks like kernel doesn't care about init.d, calling all init.d scripts via ArchiDroid Init!" >> $LOG
	for f in `find /system/etc/init.d -type f`; do
		echo "INFO: Calling $f" >> $LOG
		sh $f &
	done
else
	echo "INFO: It looks like kernel executed init.d properly, that's nice" >> $LOG
fi

# Finish
echo "INFO: ArchiDroid Init finished" >> $LOG
echo "`date`" >> $LOG
exit 0